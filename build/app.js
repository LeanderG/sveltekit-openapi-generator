import { respond } from "@sveltejs/kit/ssr";
import { create_ssr_component, validate_component, missing_component, escape } from "svelte/internal";
import { setContext, afterUpdate, onMount } from "svelte";
import cookie from "cookie";
import { v4 } from "@lukeed/uuid";
var root_svelte_svelte_type_style_lang = "#svelte-announcer.svelte-1j55zn5{position:absolute;left:0;top:0;clip:rect(0 0 0 0);clip-path:inset(50%);overflow:hidden;white-space:nowrap;width:1px;height:1px}";
const css = {
  code: "#svelte-announcer.svelte-1j55zn5{position:absolute;left:0;top:0;clip:rect(0 0 0 0);clip-path:inset(50%);overflow:hidden;white-space:nowrap;width:1px;height:1px}",
  map: `{"version":3,"file":"root.svelte","sources":["root.svelte"],"sourcesContent":["<!-- This file is generated by @sveltejs/kit \u2014 do not edit it! -->\\n<script>\\n\\timport { setContext, afterUpdate, onMount } from 'svelte';\\n\\n\\t// stores\\n\\texport let stores;\\n\\texport let page;\\n\\n\\texport let components;\\n\\texport let props_0 = null;\\n\\texport let props_1 = null;\\n\\texport let props_2 = null;\\n\\n\\tsetContext('__svelte__', stores);\\n\\n\\t$: stores.page.set(page);\\n\\tafterUpdate(stores.page.notify);\\n\\n\\tlet mounted = false;\\n\\tlet navigated = false;\\n\\tlet title = null;\\n\\n\\tonMount(() => {\\n\\t\\tconst unsubscribe = stores.page.subscribe(() => {\\n\\t\\t\\tif (mounted) {\\n\\t\\t\\t\\tnavigated = true;\\n\\t\\t\\t\\ttitle = document.title || 'untitled page';\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tmounted = true;\\n\\t\\treturn unsubscribe;\\n\\t});\\n<\/script>\\n\\n<svelte:component this={components[0]} {...(props_0 || {})}>\\n\\t{#if components[1]}\\n\\t\\t<svelte:component this={components[1]} {...(props_1 || {})}>\\n\\t\\t\\t{#if components[2]}\\n\\t\\t\\t\\t<svelte:component this={components[2]} {...(props_2 || {})}/>\\n\\t\\t\\t{/if}\\n\\t\\t</svelte:component>\\n\\t{/if}\\n</svelte:component>\\n\\n{#if mounted}\\n\\t<div id=\\"svelte-announcer\\" aria-live=\\"assertive\\" aria-atomic=\\"true\\">\\n\\t\\t{#if navigated}\\n\\t\\t\\t{title}\\n\\t\\t{/if}\\n\\t</div>\\n{/if}\\n\\n<style>\\n\\t#svelte-announcer {\\n\\t\\tposition: absolute;\\n\\t\\tleft: 0;\\n\\t\\ttop: 0;\\n\\t\\tclip: rect(0 0 0 0);\\n\\t\\tclip-path: inset(50%);\\n\\t\\toverflow: hidden;\\n\\t\\twhite-space: nowrap;\\n\\t\\twidth: 1px;\\n\\t\\theight: 1px;\\n\\t}\\n</style>"],"names":[],"mappings":"AAsDC,iBAAiB,eAAC,CAAC,AAClB,QAAQ,CAAE,QAAQ,CAClB,IAAI,CAAE,CAAC,CACP,GAAG,CAAE,CAAC,CACN,IAAI,CAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CACnB,SAAS,CAAE,MAAM,GAAG,CAAC,CACrB,QAAQ,CAAE,MAAM,CAChB,WAAW,CAAE,MAAM,CACnB,KAAK,CAAE,GAAG,CACV,MAAM,CAAE,GAAG,AACZ,CAAC"}`
};
const Root = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { stores } = $$props;
  let { page } = $$props;
  let { components } = $$props;
  let { props_0 = null } = $$props;
  let { props_1 = null } = $$props;
  let { props_2 = null } = $$props;
  setContext("__svelte__", stores);
  afterUpdate(stores.page.notify);
  let mounted = false;
  let navigated = false;
  let title = null;
  onMount(() => {
    const unsubscribe = stores.page.subscribe(() => {
      if (mounted) {
        navigated = true;
        title = document.title || "untitled page";
      }
    });
    mounted = true;
    return unsubscribe;
  });
  if ($$props.stores === void 0 && $$bindings.stores && stores !== void 0)
    $$bindings.stores(stores);
  if ($$props.page === void 0 && $$bindings.page && page !== void 0)
    $$bindings.page(page);
  if ($$props.components === void 0 && $$bindings.components && components !== void 0)
    $$bindings.components(components);
  if ($$props.props_0 === void 0 && $$bindings.props_0 && props_0 !== void 0)
    $$bindings.props_0(props_0);
  if ($$props.props_1 === void 0 && $$bindings.props_1 && props_1 !== void 0)
    $$bindings.props_1(props_1);
  if ($$props.props_2 === void 0 && $$bindings.props_2 && props_2 !== void 0)
    $$bindings.props_2(props_2);
  $$result.css.add(css);
  {
    stores.page.set(page);
  }
  return `


${validate_component(components[0] || missing_component, "svelte:component").$$render($$result, Object.assign(props_0 || {}), {}, {
    default: () => `${components[1] ? `${validate_component(components[1] || missing_component, "svelte:component").$$render($$result, Object.assign(props_1 || {}), {}, {
      default: () => `${components[2] ? `${validate_component(components[2] || missing_component, "svelte:component").$$render($$result, Object.assign(props_2 || {}), {}, {})}` : ``}`
    })}` : ``}`
  })}

${mounted ? `<div id="${"svelte-announcer"}" aria-live="${"assertive"}" aria-atomic="${"true"}" class="${"svelte-1j55zn5"}">${navigated ? `${escape(title)}` : ``}</div>` : ``}`;
});
function set_paths(paths) {
}
function set_prerendering(value) {
}
const handle = async ({ request, resolve }) => {
  const cookies = cookie.parse(request.headers.cookie || "");
  request.locals.userid = cookies.userid || v4();
  if (request.query.has("_method")) {
    request.method = request.query.get("_method").toUpperCase();
  }
  const response = await resolve(request);
  if (!cookies.userid) {
    response.headers["set-cookie"] = `userid=${request.locals.userid}; Path=/; HttpOnly`;
  }
  return response;
};
var user_hooks = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  handle
});
const template = ({ head, body }) => '<!DOCTYPE html>\n<html lang="en">\n	<head>\n		<meta charset="utf-8" />\n		<link rel="icon" href="/favicon.png" />\n		<meta name="viewport" content="width=device-width, initial-scale=1" />\n\n		' + head + '\n	</head>\n	<body>\n		<div id="svelte">' + body + "</div>\n	</body>\n</html>\n";
let options = null;
function init(settings) {
  set_paths(settings.paths);
  set_prerendering(settings.prerendering || false);
  options = {
    amp: false,
    dev: false,
    entry: {
      file: "/./_app/start-3261a039.js",
      css: ["/./_app/assets/start-a8cd1609.css"],
      js: ["/./_app/start-3261a039.js", "/./_app/chunks/vendor-4e0cc74e.js"]
    },
    fetched: void 0,
    floc: false,
    get_component_path: (id) => "/./_app/" + entry_lookup[id],
    get_stack: (error2) => String(error2),
    handle_error: (error2) => {
      console.error(error2.stack);
      error2.stack = options.get_stack(error2);
    },
    hooks: get_hooks(user_hooks),
    hydrate: true,
    initiator: void 0,
    load_component,
    manifest,
    paths: settings.paths,
    read: settings.read,
    root: Root,
    router: true,
    ssr: true,
    target: "#svelte",
    template,
    trailing_slash: "never"
  };
}
const empty = () => ({});
const manifest = {
  assets: [{ "file": "favicon.png", "size": 1571, "type": "image/png" }, { "file": "robots.txt", "size": 67, "type": "text/plain" }, { "file": "svelte-welcome.png", "size": 360807, "type": "image/png" }, { "file": "svelte-welcome.webp", "size": 115470, "type": "image/webp" }],
  layout: "src/routes/__layout.svelte",
  error: ".svelte-kit/build/components/error.svelte",
  routes: [
    {
      type: "page",
      pattern: /^\/$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/index.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/pet\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/pet.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    }
  ]
};
const get_hooks = (hooks) => ({
  getSession: hooks.getSession || (() => ({})),
  handle: hooks.handle || (({ request, resolve }) => resolve(request))
});
const module_lookup = {
  "src/routes/__layout.svelte": () => Promise.resolve().then(function() {
    return __layout;
  }),
  ".svelte-kit/build/components/error.svelte": () => Promise.resolve().then(function() {
    return error;
  }),
  "src/routes/index.svelte": () => Promise.resolve().then(function() {
    return index;
  }),
  "src/routes/pet.svelte": () => Promise.resolve().then(function() {
    return pet;
  })
};
const metadata_lookup = { "src/routes/__layout.svelte": { "entry": "/./_app/pages/__layout.svelte-960884f0.js", "css": [], "js": ["/./_app/pages/__layout.svelte-960884f0.js", "/./_app/chunks/vendor-4e0cc74e.js"], "styles": null }, ".svelte-kit/build/components/error.svelte": { "entry": "/./_app/error.svelte-6c9472a3.js", "css": [], "js": ["/./_app/error.svelte-6c9472a3.js", "/./_app/chunks/vendor-4e0cc74e.js"], "styles": null }, "src/routes/index.svelte": { "entry": "/./_app/pages/index.svelte-af18cc60.js", "css": [], "js": ["/./_app/pages/index.svelte-af18cc60.js", "/./_app/chunks/vendor-4e0cc74e.js"], "styles": null }, "src/routes/pet.svelte": { "entry": "/./_app/pages/pet.svelte-34be4a79.js", "css": [], "js": ["/./_app/pages/pet.svelte-34be4a79.js", "/./_app/chunks/vendor-4e0cc74e.js"], "styles": null } };
async function load_component(file) {
  return {
    module: await module_lookup[file](),
    ...metadata_lookup[file]
  };
}
init({ paths: { "base": "", "assets": "/." } });
function render(request, {
  prerender: prerender2
} = {}) {
  const host = request.headers["host"];
  return respond({ ...request, host }, options, { prerender: prerender2 });
}
const _layout = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `<main>${slots.default ? slots.default({}) : ``}</main>`;
});
var __layout = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": _layout
});
function load$1({ error: error2, status }) {
  return { props: { error: error2, status } };
}
const Error$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { status } = $$props;
  let { error: error2 } = $$props;
  if ($$props.status === void 0 && $$bindings.status && status !== void 0)
    $$bindings.status(status);
  if ($$props.error === void 0 && $$bindings.error && error2 !== void 0)
    $$bindings.error(error2);
  return `<h1>${escape(status)}</h1>

<p>${escape(error2.message)}</p>


${error2.stack ? `<pre>${escape(error2.stack)}</pre>` : ``}`;
});
var error = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Error$1,
  load: load$1
});
const prerender = true;
const Routes = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${$$result.head += `${$$result.title = `<title>Home</title>`, ""}`, ""}

<section><a sveltekit:prefetch href="${"/pet"}">TODOs</a></section>`;
});
var index = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Routes,
  prerender
});
const BASE_PATH = "http://localhost/api/v3".replace(/\/+$/, "");
const isBlob = (value) => typeof Blob !== "undefined" && value instanceof Blob;
class BaseAPI {
  constructor(configuration = new Configuration()) {
    this.configuration = configuration;
    this.fetchApi = async (url, init2) => {
      let fetchParams = { url, init: init2 };
      for (const middleware of this.middleware) {
        if (middleware.pre) {
          fetchParams = await middleware.pre({
            fetch: this.fetchApi,
            ...fetchParams
          }) || fetchParams;
        }
      }
      let response = await this.configuration.fetchApi(fetchParams.url, fetchParams.init);
      for (const middleware of this.middleware) {
        if (middleware.post) {
          response = await middleware.post({
            fetch: this.fetchApi,
            url,
            init: init2,
            response: response.clone()
          }) || response;
        }
      }
      return response;
    };
    this.middleware = configuration.middleware;
  }
  withMiddleware(...middlewares) {
    const next = this.clone();
    next.middleware = next.middleware.concat(...middlewares);
    return next;
  }
  withPreMiddleware(...preMiddlewares) {
    const middlewares = preMiddlewares.map((pre) => ({ pre }));
    return this.withMiddleware(...middlewares);
  }
  withPostMiddleware(...postMiddlewares) {
    const middlewares = postMiddlewares.map((post) => ({ post }));
    return this.withMiddleware(...middlewares);
  }
  async request(context) {
    const { url, init: init2 } = this.createFetchParams(context);
    const response = await this.fetchApi(url, init2);
    if (response.status >= 200 && response.status < 300) {
      return response;
    }
    throw response;
  }
  createFetchParams(context) {
    let url = this.configuration.basePath + context.path;
    if (context.query !== void 0 && Object.keys(context.query).length !== 0) {
      url += "?" + this.configuration.queryParamsStringify(context.query);
    }
    const body = typeof FormData !== "undefined" && context.body instanceof FormData || context.body instanceof URLSearchParams || isBlob(context.body) ? context.body : JSON.stringify(context.body);
    const headers = Object.assign({}, this.configuration.headers, context.headers);
    const init2 = {
      method: context.method,
      headers,
      body,
      credentials: this.configuration.credentials
    };
    return { url, init: init2 };
  }
  clone() {
    const constructor = this.constructor;
    const next = new constructor(this.configuration);
    next.middleware = this.middleware.slice();
    return next;
  }
}
class RequiredError extends Error {
  constructor(field, msg) {
    super(msg);
    this.field = field;
    this.name = "RequiredError";
  }
}
class Configuration {
  constructor(configuration = {}) {
    this.configuration = configuration;
  }
  get basePath() {
    return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;
  }
  get fetchApi() {
    return this.configuration.fetchApi || window.fetch.bind(window);
  }
  get middleware() {
    return this.configuration.middleware || [];
  }
  get queryParamsStringify() {
    return this.configuration.queryParamsStringify || querystring;
  }
  get username() {
    return this.configuration.username;
  }
  get password() {
    return this.configuration.password;
  }
  get apiKey() {
    const apiKey = this.configuration.apiKey;
    if (apiKey) {
      return typeof apiKey === "function" ? apiKey : () => apiKey;
    }
    return void 0;
  }
  get accessToken() {
    const accessToken = this.configuration.accessToken;
    if (accessToken) {
      return typeof accessToken === "function" ? accessToken : () => accessToken;
    }
    return void 0;
  }
  get headers() {
    return this.configuration.headers;
  }
  get credentials() {
    return this.configuration.credentials;
  }
}
function querystring(params, prefix = "") {
  return Object.keys(params).map((key) => {
    const fullKey = prefix + (prefix.length ? `[${key}]` : key);
    const value = params[key];
    if (value instanceof Array) {
      const multiValue = value.map((singleValue) => encodeURIComponent(String(singleValue))).join(`&${encodeURIComponent(fullKey)}=`);
      return `${encodeURIComponent(fullKey)}=${multiValue}`;
    }
    if (value instanceof Date) {
      return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;
    }
    if (value instanceof Object) {
      return querystring(value, fullKey);
    }
    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;
  }).filter((part) => part.length > 0).join("&");
}
class JSONApiResponse {
  constructor(raw, transformer = (jsonValue) => jsonValue) {
    this.raw = raw;
    this.transformer = transformer;
  }
  async value() {
    return this.transformer(await this.raw.json());
  }
}
class VoidApiResponse {
  constructor(raw) {
    this.raw = raw;
  }
  async value() {
    return void 0;
  }
}
class PetApi extends BaseAPI {
  async addPetRaw(requestParameters) {
    if (requestParameters.pet === null || requestParameters.pet === void 0) {
      throw new RequiredError("pet", "Required parameter requestParameters.pet was null or undefined when calling addPet.");
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.accessToken) {
      if (typeof this.configuration.accessToken === "function") {
        headerParameters["Authorization"] = this.configuration.accessToken("petstore_auth", ["write:pets", "read:pets"]);
      } else {
        headerParameters["Authorization"] = this.configuration.accessToken;
      }
    }
    const response = await this.request({
      path: `/pet`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.pet
    });
    return new JSONApiResponse(response);
  }
  async addPet(requestParameters) {
    const response = await this.addPetRaw(requestParameters);
    return await response.value();
  }
  async deletePetRaw(requestParameters) {
    if (requestParameters.petId === null || requestParameters.petId === void 0) {
      throw new RequiredError("petId", "Required parameter requestParameters.petId was null or undefined when calling deletePet.");
    }
    const queryParameters = {};
    const headerParameters = {};
    if (requestParameters.apiKey !== void 0 && requestParameters.apiKey !== null) {
      headerParameters["api_key"] = String(requestParameters.apiKey);
    }
    if (this.configuration && this.configuration.accessToken) {
      if (typeof this.configuration.accessToken === "function") {
        headerParameters["Authorization"] = this.configuration.accessToken("petstore_auth", ["write:pets", "read:pets"]);
      } else {
        headerParameters["Authorization"] = this.configuration.accessToken;
      }
    }
    const response = await this.request({
      path: `/pet/{petId}`.replace(`{${"petId"}}`, encodeURIComponent(String(requestParameters.petId))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    });
    return new VoidApiResponse(response);
  }
  async deletePet(requestParameters) {
    await this.deletePetRaw(requestParameters);
  }
  async findPetsByStatusRaw(requestParameters) {
    const queryParameters = {};
    if (requestParameters.status !== void 0) {
      queryParameters["status"] = requestParameters.status;
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      if (typeof this.configuration.accessToken === "function") {
        headerParameters["Authorization"] = this.configuration.accessToken("petstore_auth", ["write:pets", "read:pets"]);
      } else {
        headerParameters["Authorization"] = this.configuration.accessToken;
      }
    }
    const response = await this.request({
      path: `/pet/findByStatus`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    });
    return new JSONApiResponse(response);
  }
  async findPetsByStatus(requestParameters) {
    const response = await this.findPetsByStatusRaw(requestParameters);
    return await response.value();
  }
  async findPetsByTagsRaw(requestParameters) {
    const queryParameters = {};
    if (requestParameters.tags) {
      queryParameters["tags"] = requestParameters.tags;
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      if (typeof this.configuration.accessToken === "function") {
        headerParameters["Authorization"] = this.configuration.accessToken("petstore_auth", ["write:pets", "read:pets"]);
      } else {
        headerParameters["Authorization"] = this.configuration.accessToken;
      }
    }
    const response = await this.request({
      path: `/pet/findByTags`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    });
    return new JSONApiResponse(response);
  }
  async findPetsByTags(requestParameters) {
    const response = await this.findPetsByTagsRaw(requestParameters);
    return await response.value();
  }
  async getPetByIdRaw(requestParameters) {
    if (requestParameters.petId === null || requestParameters.petId === void 0) {
      throw new RequiredError("petId", "Required parameter requestParameters.petId was null or undefined when calling getPetById.");
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["api_key"] = this.configuration.apiKey("api_key");
    }
    if (this.configuration && this.configuration.accessToken) {
      if (typeof this.configuration.accessToken === "function") {
        headerParameters["Authorization"] = this.configuration.accessToken("petstore_auth", ["write:pets", "read:pets"]);
      } else {
        headerParameters["Authorization"] = this.configuration.accessToken;
      }
    }
    const response = await this.request({
      path: `/pet/{petId}`.replace(`{${"petId"}}`, encodeURIComponent(String(requestParameters.petId))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    });
    return new JSONApiResponse(response);
  }
  async getPetById(requestParameters) {
    const response = await this.getPetByIdRaw(requestParameters);
    return await response.value();
  }
  async updatePetRaw(requestParameters) {
    if (requestParameters.pet === null || requestParameters.pet === void 0) {
      throw new RequiredError("pet", "Required parameter requestParameters.pet was null or undefined when calling updatePet.");
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.accessToken) {
      if (typeof this.configuration.accessToken === "function") {
        headerParameters["Authorization"] = this.configuration.accessToken("petstore_auth", ["write:pets", "read:pets"]);
      } else {
        headerParameters["Authorization"] = this.configuration.accessToken;
      }
    }
    const response = await this.request({
      path: `/pet`,
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.pet
    });
    return new JSONApiResponse(response);
  }
  async updatePet(requestParameters) {
    const response = await this.updatePetRaw(requestParameters);
    return await response.value();
  }
  async updatePetWithFormRaw(requestParameters) {
    if (requestParameters.petId === null || requestParameters.petId === void 0) {
      throw new RequiredError("petId", "Required parameter requestParameters.petId was null or undefined when calling updatePetWithForm.");
    }
    const queryParameters = {};
    if (requestParameters.name !== void 0) {
      queryParameters["name"] = requestParameters.name;
    }
    if (requestParameters.status !== void 0) {
      queryParameters["status"] = requestParameters.status;
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      if (typeof this.configuration.accessToken === "function") {
        headerParameters["Authorization"] = this.configuration.accessToken("petstore_auth", ["write:pets", "read:pets"]);
      } else {
        headerParameters["Authorization"] = this.configuration.accessToken;
      }
    }
    const response = await this.request({
      path: `/pet/{petId}`.replace(`{${"petId"}}`, encodeURIComponent(String(requestParameters.petId))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    });
    return new VoidApiResponse(response);
  }
  async updatePetWithForm(requestParameters) {
    await this.updatePetWithFormRaw(requestParameters);
  }
  async uploadFileRaw(requestParameters) {
    if (requestParameters.petId === null || requestParameters.petId === void 0) {
      throw new RequiredError("petId", "Required parameter requestParameters.petId was null or undefined when calling uploadFile.");
    }
    const queryParameters = {};
    if (requestParameters.additionalMetadata !== void 0) {
      queryParameters["additionalMetadata"] = requestParameters.additionalMetadata;
    }
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/octet-stream";
    if (this.configuration && this.configuration.accessToken) {
      if (typeof this.configuration.accessToken === "function") {
        headerParameters["Authorization"] = this.configuration.accessToken("petstore_auth", ["write:pets", "read:pets"]);
      } else {
        headerParameters["Authorization"] = this.configuration.accessToken;
      }
    }
    const response = await this.request({
      path: `/pet/{petId}/uploadImage`.replace(`{${"petId"}}`, encodeURIComponent(String(requestParameters.petId))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    });
    return new JSONApiResponse(response);
  }
  async uploadFile(requestParameters) {
    const response = await this.uploadFileRaw(requestParameters);
    return await response.value();
  }
}
var FindPetsByStatusStatusEnum;
(function(FindPetsByStatusStatusEnum2) {
  FindPetsByStatusStatusEnum2["Available"] = "available";
  FindPetsByStatusStatusEnum2["Pending"] = "pending";
  FindPetsByStatusStatusEnum2["Sold"] = "sold";
})(FindPetsByStatusStatusEnum || (FindPetsByStatusStatusEnum = {}));
var OrderStatusEnum;
(function(OrderStatusEnum2) {
  OrderStatusEnum2["Placed"] = "placed";
  OrderStatusEnum2["Approved"] = "approved";
  OrderStatusEnum2["Delivered"] = "delivered";
})(OrderStatusEnum || (OrderStatusEnum = {}));
var PetStatusEnum;
(function(PetStatusEnum2) {
  PetStatusEnum2["Available"] = "available";
  PetStatusEnum2["Pending"] = "pending";
  PetStatusEnum2["Sold"] = "sold";
})(PetStatusEnum || (PetStatusEnum = {}));
const getPetApi = (fetchApi) => {
  const configurationParameters = {
    fetchApi,
    basePath: "https://petstore3.swagger.io/api/v3"
  };
  const configuration = new Configuration(configurationParameters);
  return new PetApi(configuration);
};
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const load = ({ fetch }) => __awaiter(void 0, void 0, void 0, function* () {
  const petApi = getPetApi(fetch);
  console.log("test");
  const pet2 = yield petApi.getPetById({ petId: 100 });
  console.log("test2", { pet: pet2 });
  return { props: { pet: pet2 } };
});
const Pet = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { pet: pet2 } = $$props;
  if ($$props.pet === void 0 && $$bindings.pet && pet2 !== void 0)
    $$bindings.pet(pet2);
  return `Hello!
${escape(JSON.stringify(pet2))}`;
});
var pet = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Pet,
  load
});
export { init, render };
